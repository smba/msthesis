While to the best of our knowledge, there exists no previous work onexhaustively presenting a methodology to understand and comprehend performanceevolution of configurable system, existing related work and ours have eithertouched on similar topics, or pursue a similar methodology, yet with differentbasic premises. In the following we present and summarize related work toemphasize the limited scope of our work, and to give an outline of possiblefuture research directions.\paragraph{Comprehending Software Evolution.} Throughout our methodology, wehave frequently referred to visualizations of data obtained from repositorymining, for instance, for commit activity, and as a basis for revision samplingstrategies. In addition, we have taken into account similar data in theinterpretation of our performance evolution history data in section. Moregenerally speaking, software as a product is the result of a complexdevelopment process involving a repeatedly revised codebase, testing anddocumentation activity as well as records of developer communication, andorganizational artifacts and speifications. As software evolves, hence, it isinevitable to not consider those data to obtain more complete and integratedinsights. Aggregation and visualization of aforementioned data records can helpto sketch and understand possible coherences.\cite{german_visualizing_2006} have presented a comprehensive tool,\emph{softChange}, to visualize multiple aspects of a software system’sevolution history, including commit and file activity graphs, authorshipoverviews, and visualizations of file coupling. While their tool is notdesigned with regard to a specific research direction, the authors stress theimportance of means to aggregate and analyze software trails in order toexplore and understand software evolution. Joint visualizationsof software trails as well as performance evolution history data is a promisingaugmentation in the comprehension of multi-layered software evolution.\cite{wu_exploring_2004} have presented presented an integrated approach tovisualize multiple different measurements over time. Their proposed\emph{evolution spectrum graphs} are inspired by spectrum visualizations foraudio signals. A spectrum in their context can, for instance,  be a list of files, for whichdifferent measurements are illustrated over time. While this approach allows aglobal overview over an arbitrary timespan, it also can sketch fine-grainedchanges and trends over time. Although, according to the authors, thevisualizations need to be tailored to the target system with respect tocoloring and spectrum selection, evolution spectrum graphs can be a usefulmeans to aggregate and visualize various single-valued measurements for aspectrum of variants for configurable software systems.To conclude with a broader overview on visualization tools for further reading,\cite{storey_use_2005} have surveyed twelve tools (including the previouslymentioned two) that intend to visualize any kind of human activities insoftware development with a string focus on software evolution. The authorsevaluate the different tools with respect to different aspects, includingintent of the tools, the information sources utilized by the tools, the form ofpresentation offered by the tools, and the effectiveness in terms offeasibility and validity.\paragraph{Power Consumption as a Performance Property.}With the grown popularity of mobile devices, such as smartphones, over the lastdecade, power consumption of software systems has emerged to become aconsiderable software quality attribute beside established performanceindicators. In the context of limited resources, end-user requirementsaccentuate the demand of power-saving software applications, yet many apps havenet kept up so far \citep{li_empirical_2014}. Recent research activities have taken up this subject, and address the powerconsumption of software systems along the lines of research focusing onsoftware performance engineering. For instance, \cite{sahin_how_2014} havestudied the impact of automated refactorings on the power consumption of almost200 software systems. The authors’ results indicate that refactorings can bothdecrease and increase power consumption, and that a refactorings’ impact onpower consumption is hardly predictable as the effects observed neithercorrelated with traditional software performance metrics nor followed anyconsistent pattern \citep{sahin_how_2014}.Moreover, \cite{hindle_green_2015} have proposed a methodology, green mining, to measureand model the evolution of power consumption across different versions of asoftware system. Using their methodology, the authors have documented the powerconsumption evolution history of two different software systems, and identifiedfeasible metrics to summarize power consumption. In contrast to theobservations by \cite{sahin_how_2014}, however, the results by \cite{hindle_green_2015}suggest a relationship between structural size software metrics and powerconsumption. Compared to our proposed methodology, green mining only considersone-dimensional evolution of power consumption as different software variantsare not taken into account, yet green mining examines the relationship betweenpower consumption and further quality attributes. That is, we believe thatinterpreting performance evolution results in an extended context of softwaremetrics with respect to software architecture, power consumption, and alongestablished software analyses should direct further research activities towardsa better understanding of software evolution.